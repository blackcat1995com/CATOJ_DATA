#include <iostream>
#include <map>
#include <queue>
#include <cstdio>
#include <algorithm>
#include <stack> 
using namespace std;
//队列优化bfs 
int x[24]={0,1,2,3,4,5,6,7 ,8,9 ,10,11,12,13,14,0,1,2,4,5,6 ,8 ,9 ,10};
int y[24]={1,2,3,7,5,6,7,11,9,10,11,15,13,14,15,4,5,6,8,9,10,12,13,14};

/*0  1  2  3
  4  5  6  7
  8  9  10 11
  12 13 14 15*/
  
/*
1.将16个格子依次标记编号0~15，如上方所示。
2.将每个格子可移动的位置用数组x和y记录下来。
  如x[3]=4,y[3]=5,意为4号格中的玩具可移动至5号格，5号格中的玩具可移动至4号格。
  四角每个格子可移动至两个位置，边内每个格子可移动至3个位置，中心每个格子可移动至4个位置，
  故一共4*2+8*3+4*4=48种情况，由于是双向移动，故分两部分记录于x,y中，各24种情况。 
*/ 

map <string,int> m;//将每一种状态以字符串记录，并以map映射记录该种状态所需要的移动次数 
queue <string> q; 
int main(){
	freopen("3.in", "r", stdin);
	freopen("3.out", "w", stdout);
    string s,a,b;
    for(int i=0;i<=3;i++){//分四行输入初始状态，并将其记录于字符串a中 
        cin>>s;
        a+=s;
    }
    for(int i=0;i<=3;i++){//分四行输入目标状态，并将其记录于字符串b中 
        cin>>s;
        b+=s;
    }
    m[a]=0;//初始状态还未移动，故移动次数为0 
    q.push(a);//将初始状态插入队列 
    while(!q.empty()){//当前队列不为空，说明还未搜索结束 
        string c=q.front();//字符串c代表当前状态 
        q.pop();//将当前状态弹出队列 
        if(c==b){//若当前状态与目标状态一致，输出当前状态对应的移动次数，即为最终解。
            cout<<m[c];
            break;
        }//当然，也可不写这一步，等所有状态跑完之后，在最后输出m[b]也可以，但时间开销较大。 
        for(int i=0;i<24;i++){//共24对可互换的位置，记录与x和y数组中 
                string d=c;//字符串d代表移动后的状态 
                if(d[x[i]]!=d[y[i]]){//若位置互换后状态发生变化，则移动玩具 
                    swap(d[x[i]],d[y[i]]);
                    if(m[d]==0){//如果移动后的状态为新状态，则将新状态插入队列，同时移动次数+1; 
                        q.push(d); 
                        m[d]=m[c]+1;
                    }
                }
        }
    }
    return 0;
}

/*
1111
0000
1110
0010

1010
0101
1010
0101
*/
